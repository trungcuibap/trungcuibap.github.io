<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Quản lý bộ nhớ trong Java với Heap và Stack Memory</title>
      <link href="/2020/07/18/quan-ly-bo-nho-java/"/>
      <url>/2020/07/18/quan-ly-bo-nho-java/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/08/Java-Heap-Stack-Memory.png" alt="Java Runtime Memory"></p><h3 id="Mot-so-dinh-nghia"><a href="#Mot-so-dinh-nghia" class="headerlink" title="Một số định nghĩa:"></a>Một số định nghĩa:</h3><ul><li>Runtime: Thời gian chương trình chạy</li><li>Java Heap Memory(Heap): Bộ nhớ Heap trong java</li><li>Java Stack Memory (Stack): Bộ nhớ Stack trong java</li><li>JVM (Java Virtual Machine): Máy ảo java dùng để chạy chương trình (apps) java của bạn. </li><li>Object: là một đối tường được khởi tạo từ từ khóa new một class.</li></ul><h3 id="Java-Heap-and-Stack-Memory-la-mot-phan-cua-bo-nho-duoc-JVM-su-dung-de-chay-chuong-trinh-java-JVM-se-yeu-cau-he-dieu-hanh-cap-cho-mot-khong-gian-bo-nho-trong-Ram-de-dung-cho-viec-chay-chuong-trinh-JVM-se-chia-bo-nho-duoc-cap-phat-thanh-2-phan-gom-Heap-va-Stack-cho-viec-quan-ly"><a href="#Java-Heap-and-Stack-Memory-la-mot-phan-cua-bo-nho-duoc-JVM-su-dung-de-chay-chuong-trinh-java-JVM-se-yeu-cau-he-dieu-hanh-cap-cho-mot-khong-gian-bo-nho-trong-Ram-de-dung-cho-viec-chay-chuong-trinh-JVM-se-chia-bo-nho-duoc-cap-phat-thanh-2-phan-gom-Heap-va-Stack-cho-viec-quan-ly" class="headerlink" title="Java Heap and Stack Memory là một phần của bộ nhớ được JVM sử dụng để chạy chương trình java, JVM sẽ yêu cầu hệ điều hành cấp cho một không gian bộ nhớ trong Ram để dùng cho việc chạy chương trình. JVM sẽ chia bộ nhớ được cấp phát thành 2 phần gồm: Heap và Stack cho việc quản lý."></a>Java Heap and Stack Memory là một phần của bộ nhớ được JVM sử dụng để chạy chương trình java, JVM sẽ yêu cầu hệ điều hành cấp cho một không gian bộ nhớ trong Ram để dùng cho việc chạy chương trình. JVM sẽ chia bộ nhớ được cấp phát thành 2 phần gồm: Heap và Stack cho việc quản lý.</h3><hr><h3 id="Nhung-diem-khac-nhau-cua-Heap-va-Stack"><a href="#Nhung-diem-khac-nhau-cua-Heap-va-Stack" class="headerlink" title="Những điểm khác nhau của Heap và Stack"></a>Những điểm khác nhau của Heap và Stack</h3><table><thead><tr><th>Java Heap Memory</th><th>Java Stack Memory</th></tr></thead><tbody><tr><td>Java Heap Memory là bộ nhớ được sử dụng ở runtime để lưu các Objects. Bất cứ khi nào ở đâu trong chương trình của bạn khi bạn tạo Object thì nó sẽ được lưu trong Heap (thực thi toán tử new).</td><td>Stack Memory là bộ nhớ để lưu các biến local trong hàm và lời gọi hàm ở runtime trong một Thread java. Các biến local bao gồm: loại nguyên thuỷ (primitive), loại tham chiếu tới đối tượng trong heap (reference), khai báo trong hàm, hoặc đối số được truyền vào hàm.</td></tr><tr><td>Thời gian sống của bộ nhớ Heap dài hơn so với Stack.<br>Thời gian sống của object phụ thuộc vào Garbage Collection của java. Garbage Collection sẽ chạy trên bộ nhớ Heap để xoá các Object không được sử dụng nữa, nghĩa là object không được referece trong chương trình.</td><td>Thường có thời gian sống ngắn.</td></tr><tr><td>Các objects trong Heap đều được truy cập bởi tất cả các các nơi trong ứng dụng, bởi các threads khác nhau.</td><td>Stack chỉ được sử dụng cho một Thread duy nhất. Thread ngoài không thể truy cập vào được.</td></tr><tr><td>Cơ chế quản lý của Heap thì phức tạp hơn. Heap được phân làm 2 loại Young-Generation, Old-Generation</td><td>Cơ chế hoạt động là LIFO (Last-In-First-Out), chạy sau chết trước.</td></tr><tr><td>Dung lượng Heap thường lớn hơn Stack.</td><td>Bộ nhớ stack thường nhỏ.</td></tr><tr><td>Sử dụng -Xms và -Xmx để định nghĩa dung lượng bắt đầu và dung lượng tối đa của bộ nhớ heap.</td><td>Dùng -Xss để định nghĩa dung lượng bộ nhớ stack.</td></tr><tr><td>Khi Heap bị đầy chương trình hiện lỗi java.lang.OutOfMemoryError: Java Heap Space</td><td>Khi stack bị đầy bộ nhớ, chương trình phát sinh lỗi: java.lang.StackOverFlowError</td></tr><tr><td>Truy cập vùng nhớ Heap chậm hơn Stack.</td><td>Truy cập stack nhanh hơn Heap</td></tr><tr><td>Dung lượng sử dụng của Heap sẽ tăng giảm phụ thuộc vào Objects sử dụng.</td><td>Bất cứ khi nào gọi 1 hàm, một khối bộ nhớ mới sẽ được tạo trong Stack cho hàm đó để lưu các biến local. Khi hàm thực hiện xong, khối bộ nhớ cho hàm sẽ bị xoá, và giải phóng bộ nhớ trong stack.</td></tr></tbody></table><hr><h4 id="Vi-du-nho-nho"><a href="#Vi-du-nho-nho" class="headerlink" title="Ví dụ nho nhỏ:"></a>Ví dụ nho nhỏ:</h4><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Line 1</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>; <span class="comment">// Line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object(); <span class="comment">// Line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory(); <span class="comment">// Line 4</span></span><br><span class="line">        mem.foo(obj); <span class="comment">// Line 5</span></span><br><span class="line">    &#125; <span class="comment">// Line 9</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123; <span class="comment">// Line 6</span></span><br><span class="line">        String str = param.toString(); <span class="comment">//// Line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="comment">// Line 8</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.journaldev.com/wp-content/uploads/2014/08/Java-Heap-Stack-Memory.png" alt="Java Runtime Memory"></p><p>Giải thích:</p><ul><li><p>Khi chạy chương trình, một thread sẽ khởi tạo và sẽ gọi hàm main ở dòng 1. Một khối bộ nhớ được tạo trong stack cho hàm main().</p></li><li><p>Một biến local được tạo ở dòng 2, loại primitive được lưu trong cùng khối bộ nhớ của hàm main()</p></li><li><p>Dòng 3, một đối tượng được tạo loại Object sẽ được lưu trong bộ nhớ heap và biến tham chiếu obj được lưu trong stack của hàm main()</p></li><li><p>Tương tự dòng 4, một đối tượng được tạo loại Memory lưu trong bộ nhớ heap và biến tham chiếu mem lưu trong stack.</p></li><li><p>Dòng 5 , hàm foo() thì được gọi, vì vậy nó sẽ tạo một khối mới bộ nhớ trong stack cho hàm foo()</p></li><li><p>Hàm foo có một đối số ở dòng 6, loại biến tham chiếu param tời đối tượng Object trong heap, nên đối số này sẽ được lưu trong bộ nhớ stack của foo()</p></li><li><p>Dòng 7, một biến local loại tham chiếu là str được tạo trong stack của foo(). Biến này tham chiếu tới đối tượng StringPool trong heap.</p></li><li><p>Dòng 8, hàm foo() sẽ kết thúc vì vậy bộ nhớ trong stack cho hàm foo() sẽ được giải phóng.</p></li><li><p>Theo quy luật LIFO, foo() vào sau chết trước, và sau đó hàm main() cũng kết thúc, bộ nhớ trong stack cho hàm main() cũng được giải phóng.</p></li><li><p>Chương trình kết thúc.</p></li></ul><h4 id="Happy-coding"><a href="#Happy-coding" class="headerlink" title="Happy coding! :) :) :)"></a>Happy coding! :) :) :)</h4>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[12 Rule] Rule 1: Trick Your Brain with the 20min Rule</title>
      <link href="/2020/04/25/rule-1-Trick-Your-Brain-with-the-20min-Rule/"/>
      <url>/2020/04/25/rule-1-Trick-Your-Brain-with-the-20min-Rule/</url>
      
        <content type="html"><![CDATA[<p>[English]<br>Learning to code is a bit like going to the gym. Even if you max out and spent a whole weekend at the gym, you will not see a visible difference in your body. The more regularly you learn to code, the more likely it is that you’ll start seeing your ripped coding muscles. (The irony is not lost on me).</p><p>But the problem is where do you find the time? Between working your full-time job, spending time with your family and life admin, when are you supposed to sit down and practice this “daily coding”? While I was working as a doctor, I spent about 12 hours at the hospital, 1-hour commuting and approximately 2 hours on general life-sustaining stuff, such as eating. So that left me with only 9 hours remaining in my day.<br>Theoretically, 2 hours could be allocated to coding practice and 7 hours on sleep. But there is nothing more difficult than trying to convince your work-saturated brain to sit down and learn when you could be watching Game of Thrones with a tub of ice-cream.<br>But then I found a trick.</p><p>As humans, we have a lot of inertia. This can be bad for us - I’m looking at you, “24” box set. However, we can also turn it to our advantage. I found that once I got started coding and making things, I got so absorbed into the<br>project, that I no longer cared about TV, food or sleep. There were quite a few weekends when I coded until sunrise.<br>So how do we take advantage of this inertia? First, you must understand that task-switching is very difficult. It requires a lot of motivation. If as soon as you get home, you slump on the sofa and switch on the TV, you’ve already lost that evening. This is because the amount of motivation required to task-switch and do something not driven by evolution like eating or sleeping is a Herculean task.</p><p>This is why the moment you enter the door and change to a new environment is the most crucial moment. If at this moment, you tell yourself<br>that you are just going to do 20 minutes of coding practice, you will most likely succeed and use your own inertia to end up learning for an hour or more. No brain will perceive a 20-minute task as a lot of effort and you end up tricking your brain to take advantage of your evening.</p><p>The next step is to develop a habit. Research suggests that in order to develop a new habit, you have to carry out the task daily for a month. I’ve<br>used this next trick for loads of different things, from exercising to coding, it invariably works like a charm. To preface this trick, I want you to imagine a wall with five paintings hanging on it, four of which are perfectly aligned, perfectly horizontal, but one is crooked. Now really imagine it, is there a part of you that wants to fix it?</p><p>Now let’s imagine a monthly calendar with boxes representing individual days. If you nurtured that new habit on a particular day, then you make a line through that day. If you continued your streak the next day then you extend that line and so on and so forth. There is something about not breaking a continuous line that motivates most people to continue to develop a habit. As strange as it sounds, there are many times when I would have given up, but compelled to continue because of a long, continuous line.</p><p>[Tiếng Việt] </p><h3 id="Meo-hay-cho-bo-nao-cua-ban-voi-luat-20-phut"><a href="#Meo-hay-cho-bo-nao-cua-ban-voi-luat-20-phut" class="headerlink" title="Mẹo hay cho bộ não của bạn với luật 20 phút"></a>Mẹo hay cho bộ não của bạn với luật 20 phút</h3><p>Việc học code cũng giống như việc bạn đi tập gym. Thậm chí khi bạn đã đạt được mức cân tối đa và đã dành toàn bộ 2 ngày cuối tuần đến phòng tập, nhưng bạn sẽ không nhận ra được sự khác biệt xuất hiện trên thân hình của mình. Nó còn thuờng xảy ra hơn nữa khi bạn học viết code, càng nhiều khả năng hơn nữa là bạn sẽ bắt đầu nhận thấy sự khác biệt ở những múi cơ trên cơ thể bạn ( nho nhỏ thôi nhé) </p><p>Nhưng vấn đề ở đây là bạn có thời gian để làm nó hay không?<br>Khi bạn cần thời gian để làm việc full-time, thời gian dành cho gia đình và sinh hoạt. Có khi nào bạn giả định ngồi xuống và luyện tâp viết code  hằng ngày chưa? </p><p>Trong khi tôi đang làm công việc của một bác sĩ, Tôi đã dành khoãng 12 tiếng tại bệnh viện. 1 giờ cho việc đi lại và tầm khoảng 2 giờ cho sinh hoạt ví như ăn uống chẳng hạn. Vì thế tôi chỉ còn lại khoảng 9 tiếng trong ngày.<br>Theo nghiên cứu, 2 giờ có thể dành cho việc luyện tập code và 7 giờ để ngủ. Nhưng không có gì khó hơn việc bạn ngồi xuống cố gắng thuyết phục bộ não đã bị “đơ” rằng phải học thứ gì đó thay cho việc ngồi xem phim Game of thrones với một hủ kem tươi ngon. 😊 </p><p>Nhưng tôi đã tìm ra một mẹo.<br>Là con người, chúng ta có nhiều thói quen, đôi khi là những thói quen xấu. Tuy nhiên, bạn có thể thay đổi nó thành những điểm tốt thận lợi cho mình hơn. Tôi thấy rằng một khi tôi bắt đầu coding và làm được nhiều thứ thì tôi dễ bị cuốn vào chính dự án. Tôi đã không còn quan tâm đến  TV, đồ ăn hay ngủ có khi một vài ngày cuối tuần tối code đến lúc mặt trời mọc 😊 </p><p>Vậy thì làm thế nào để tận dụng được thói quen này?<br>Đầu tiên, bạn phải hiểu được chuyển đổi công việc là rất khó khăn. Nó đòi hỏi bạn phải có nhiều động lực. Ngay khi bạn về đến nhà, bạn ngồi bệt xuống ghế sofa và bật TV lên, và thế là bận mất nguyên buổi tối. Nó là do bạn không có đủ động lực để làm thứ gì đó giống như việc ăn hay đi ngủ. Ở đây mình gọi là một Herculean task. 😀  </p><p>Điều đó cho thấy tại sao tại thời điểm đó bạn bước vào cửa nhà và cần phải thay đổi môi trường làm việc mới. Nếu ngay lúc đó, bạn tự nhủ rằng bạn chỉ có khoảng 20 min để luyện code, thì bạn sẽ có thể thành công hơn và sử dụng thói quen này để kết thúc nhanh việc luyện code trong vòng một giờ hoặc lâu hơn. Bộ não sẽ nhận thấy trong nhiệm vụ 20 phút bằng nhiều nỗ lực và kết thúc việc đánh lừa nó càng nhanh để tận dụng được buổi tối quí giá của bạn. 😉<br>Bước tiếp theo là phát triển được một thói quen. Nghiên cứu chỉ ra rằng để phát triển được một thói quen mới, bạn phải làm một việc liên tục trong vòng một tháng. Tôi đã sử dụng cách này để thực hiện nhiều công việc khác nhau, từ việc rèn luyện coding, nó cuốn hút tôi giống như mùi nước hoa vậy. Với cách này, tôi muốn bạn tưởng tường trên một bức tường có  năm bức tranh được treo lên, trong đó bốn bức được sắp xếp ngay hàng thẳng lối. Có một bức thì để không ngay ngắn. Bây giờ bạn hãy tưởng tượng bạn sẽ đi sắp xếp lại nó cho ngay ngắn. </p><p>Bây giờ hãy tưởng tượng ra một kế hoạch cho một tháng được trình bày thành từng ngày đơn lẻ. Nếu bạn nuôi dưỡng được thói quen mới này trên từng ngày cụ thể, bạn kẽ một đường thẳng trên ngày đó. Nếu ngày hôm sau tiếp tục như vậy thì bạn tiếp tục nối dài đường thẳng đó và cứ làm như vậy. Điều này nghe có vẻ hơi lạ, nhưng đã nhiều khi tôi muốn từ bỏ, nhưng khi tôi nhìn là dòng kẻ đã quá dài và liên tục. Thì tôi không muốn nữa. Và thế là tôi tiếp tục nối dài chúng.  </p><p>Continue..😉</p><hr><p>Created by Dr. Angela Yu<br>Sub VN: Trung</p><hr>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> Reading </tag>
            
            <tag> translate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note: upgrade Jdeveloper from version 12.1.3 to 12.2.1</title>
      <link href="/2020/04/25/Note-upgrade-Jdeveloper-from-version-12-1-3-to-12-2-1/"/>
      <url>/2020/04/25/Note-upgrade-Jdeveloper-from-version-12-1-3-to-12-2-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Mot-so-luu-y-khi-nang-cap-bang-jdeveloper-tu-12-1-3-len-12-2-1"><a href="#Mot-so-luu-y-khi-nang-cap-bang-jdeveloper-tu-12-1-3-len-12-2-1" class="headerlink" title="Một số lưu ý khi nâng cấp bảng jdeveloper từ 12.1.3 lên 12.2.1"></a>Một số lưu ý khi nâng cấp bảng jdeveloper từ 12.1.3 lên 12.2.1</h2><ol><li>Sử dụng java 8 thay cho java 7. Sau khi cấu hình xong, bạn phải sửa lại đường dẫn java 8 trong file<br><code>/u02/../bin/ setDomainEnv.sh</code> and <code>/u01/../fm1213/oracle_common/common/bin/commEnv.sh</code></li><li>Cấu hình Replication Http Session Cho cluster </li><li>Làm theo đúng hướng dẫn và sửa lại file java sử dụng session bằng cách implements Serializes</li><li>Bật chế độ -Dweblogic.jdbc.remoteEnabled=false-&gt;true nếu chưa bật</li></ol><p>Happy coding. =))</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Weblogic </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to add JMX to Weblogic 12c</title>
      <link href="/2020/04/25/How-to-add-JMX-to-Weblogic-12c/"/>
      <url>/2020/04/25/How-to-add-JMX-to-Weblogic-12c/</url>
      
        <content type="html"><![CDATA[<ol><li>Stop Admin Weblogic</li><li><p>Open and Edit file setDomainEnv.sh</p> <figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTIONS=<span class="string">"$&#123;JAVA_OPTIONS&#125; </span></span><br><span class="line"><span class="string"> -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8888 </span></span><br><span class="line"><span class="string"> -Dcom.sun.management.jmxremote.ssl=false</span></span><br><span class="line"><span class="string"> -Dcom.sun.management.jmxremote.authenticate=false"</span></span><br><span class="line"> export JAVA_OPTIONS</span><br><span class="line"></span><br><span class="line"> JAVA_OPTIONS=<span class="string">"$&#123;JAVA_OPTIONS&#125;"</span></span><br><span class="line"> export JAVA_OPTIONS</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> [ <span class="string">"$SERVER_NAME"</span> == <span class="string">"AdminServer"</span> ]</span><br><span class="line"> then</span><br><span class="line">         JAVA_OPTIONS=<span class="string">"$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8888 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.access.file=jmxremote.access -Dcom.sun.management.jmxremote.password.file=jmxremote.password"</span></span><br><span class="line">         export JAVA_OPTIONS</span><br><span class="line"> </span><br><span class="line"> elif [ <span class="string">"$SERVER_NAME"</span> == <span class="string">"mwiserver1"</span> ]</span><br><span class="line"> then</span><br><span class="line">         JAVA_OPTIONS=<span class="string">"$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8889 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.access.file=jmxremote.access -Dcom.sun.management.jmxremote.password.file=jmxremote.password"</span></span><br><span class="line">         export JAVA_OPTIONS     </span><br><span class="line"> fi</span><br></pre></td></tr></table></figure></li><li><p>Start Weblogic again! Finish. </p></li></ol><p>Happy coding. =))</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Weblogic </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Managing HTTP Sessions in a Cluster – In memory replication type</title>
      <link href="/2020/04/25/weblogic-http-server/"/>
      <url>/2020/04/25/weblogic-http-server/</url>
      
        <content type="html"><![CDATA[<h2 id="Mot-so-luu-y-khi-cau-hinh-Http-Sesssion-trong-Weblogic-Cluster"><a href="#Mot-so-luu-y-khi-cau-hinh-Http-Sesssion-trong-Weblogic-Cluster" class="headerlink" title="Một số lưu ý khi cấu hình Http Sesssion trong Weblogic Cluster."></a>Một số lưu ý khi cấu hình Http Sesssion trong Weblogic Cluster.</h2><ul><li><p>HTTP Session in a Cluster Weblogic gồm có 2 loại:</p><ol><li>In Memory Replication<ul><li>Thông qua memory</li></ul></li><li>JDBC (Database) Replication<ul><li>Thông qua database</li></ul></li></ol></li><li><p>Để một ứng dụng chạy Replication Http Session thì bạn cần cấu hình ở 2 phía. </p><ol><li>Application Server.</li><li>Ứng dụng đang chạy. Cụ thể là java code </li></ol></li><li><p>Điều kiện:</p><ol><li>Cài đặt Weblogic Server 12c</li><li>Tạo domain và tạo 2 AppServer chạy trên 1 Cluster.</li><li>Tạo một ứng dụng java nhỏ để test</li></ol></li></ul><ul><li><p>Chi tiết cấu hình như thế nào thì ở <a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/fmw/wls/12c/12-ManageSessions--4478/session.htm" target="_blank" rel="noopener">link này nhé</a></p></li><li><p>Mình chỉ có một số lưu ý khi Replication không hoạt động được:</p><ol><li>Phải thêm Cluster Address Trong Configuration Cluster (nếu chưa thêm)<br> <img src="https://1.bp.blogspot.com/-Rc-7RzK1fVo/W8lP4DepNnI/AAAAAAAANTM/T65DFUe9q7cPBRsGyH330m6mBcXkf6PxACLcBGAs/s400/cluster.png" alt="Cluster Address"></li><li>Edit the WEB-INF/weblogic.xml file in application file .EAR or WAR</li><li><p>Trong code java. Những object nào được lưu trong session thì phải serializable. Cách đơn giản là implements Serializable class object đó.</p><p><strong>Example:</strong></p> <figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-descriptor&gt;</span><br><span class="line">    &lt;persistent-store-type&gt;replicated_if_clustered&lt;/persistent-store-type&gt;</span><br><span class="line">&lt;/session-descriptor&gt;</span><br></pre></td></tr></table></figure> <figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Tạm kết</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Weblogic </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
